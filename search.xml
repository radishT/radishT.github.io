<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java应用线上问题排查(1)</title>
      <link href="/2019/04/25/jvmnote1/"/>
      <url>/2019/04/25/jvmnote1/</url>
      
        <content type="html"><![CDATA[<h1 id="Java应用上线时常会遇到一些事故"><a href="#Java应用上线时常会遇到一些事故" class="headerlink" title="Java应用上线时常会遇到一些事故"></a>Java应用上线时常会遇到一些事故</h1><p>为了避免和读者的实际情况产生偏离,我先介绍我的整个生产环境:</p><blockquote><p>JDK:Java1.8</p></blockquote><blockquote><p>MySQL : 5.6</p></blockquote><blockquote><p>Linux CentOS 6.5</p></blockquote><p>过程中参考过的一些他人的文章<a href="https://zhuanlan.zhihu.com/p/59279569?utm_source=qq&amp;utm_medium=social&amp;utm_oi=822385365787766784" target="_blank" rel="noopener">一次 Java 内存泄漏的排查</a></p><h2 id="一-场景1-发生线上问题后-该怎么做"><a href="#一-场景1-发生线上问题后-该怎么做" class="headerlink" title="一.场景1 发生线上问题后,该怎么做"></a>一.场景1 发生线上问题后,该怎么做</h2><h3 id="保留现场"><a href="#保留现场" class="headerlink" title="保留现场"></a>保留现场</h3><pre><code>这里的保留现场是一个宽泛的概念,我一般是根据问题来做这一步,以下是我的一些思路:</code></pre><p>1.先看日志报错,比如是out of memory 就基本可以定位问题在JVM而不是操作系统的问题,所以只需要保存一些必要的JVM现场即可.<br>2.但是如果是一些TCP连接耗尽(TIME_WAITING例如SYN,ddos攻击)、TCP链接没有及时释放(表现在服务不可用)、<br>网络丢包波动之类的网络异常、kafka消息不完整等问题,就需要保留操作系统<br>或者kafka组件的日志信息了,后续介绍这方面的方法  </p><h4 id="保留JVM的堆栈信息的方法"><a href="#保留JVM的堆栈信息的方法" class="headerlink" title="保留JVM的堆栈信息的方法"></a>保留JVM的堆栈信息的方法</h4><p>保留栈信息:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jstack pid &gt; stack.log</span><br><span class="line">```  </span><br><span class="line">保留堆信息:  </span><br><span class="line">```shell</span><br><span class="line">jmap -dump:format=b,file=heap.log pid</span><br></pre></td></tr></table></figure></p><p>查询PID的方式很多,如果确定服务所在的端口可以用:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat   -anp   |   grep  portno</span><br></pre></td></tr></table></figure></p><p>一般来说都会用 top 去定位运行异常(比如CPU占用过高,内存占用过高)的PID  </p><h3 id="确认问题"><a href="#确认问题" class="headerlink" title="确认问题"></a>确认问题</h3><p>有时候我们并不能在刚才的保留现场阶段就确认到问题,比如简单的top或者<br>程序日志无法帮助我们确认问题在哪里,我们可以进一步分析我们保留的堆栈信息,这里<br>例举几个通过日志可以看到的问题:<br>1.获取GC运行概况</p><pre><code class="shell">jstat -gcutil pid</code></pre><p>解析输出的内容(举例1 堆内存爆炸导致FullGC频繁STW <a href="https://blog.csdn.net/weiquanaishiyao/article/details/83578999" target="_blank" rel="noopener">参考博客</a>):<br><img src="/images/jvmnote1.png" alt><br><img src="https://img-blog.csdnimg.cn/20181031094752146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXF1YW5haXNoaXlhbw==,size_16,color_FFFFFF,t_70" alt></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 线上问题排查 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
